<head>
</head>
<body>
    <main>
  <div class="products">

    <% products.forEach(product => { %>
      <div class="product">
        <div class="fancy-slider">
          <div class="slider-track">
            <% product.images.forEach((image, idx) => { %>
              <div class="slide">
                <img src="<%= image %>" alt="<%= product.name %>" loading="lazy">
              </div>
            <% }) %>
          </div>

          <!-- pagination dots -->
          <div class="slider-dots">
            <% product.images.forEach((image, idx) => { %>
              <button class="dot" aria-label="slide <%= idx+1 %>"></button>
            <% }) %>
          </div>

          <!-- overlay effect -->
          <div class="slider-overlay"></div>
        </div>

        <h3><%= product.name %></h3>
        <p><%= product.price %> ج.م</p>

        <% if (product.labels && product.labels.length > 0) { %>
          <div class="labels">
            <% product.labels.forEach(label => { %>
              <span><%= label %></span>
            <% }) %>
          </div>
        <% } %>

      </div>
    <% }) %>

  </div>
</main>

  <script>
    // أنميشن الوسوم
    document.querySelectorAll(".labels").forEach(labelBox => {
      const spans = labelBox.querySelectorAll("span");
      let index = 0;

      function cycleLabels() {
        spans.forEach(span => span.classList.remove("show", "hide"));

        spans[index].classList.add("show");

        setTimeout(() => {
          spans[index].classList.add("hide");
          index = (index + 1) % spans.length;
          setTimeout(cycleLabels, 800); // بعد ما تختفي، يعرض اللي بعدها
        }, 1200); // مدة عرض كل وسم
      }

      if (spans.length > 0) cycleLabels();
    });
   // تعدد الصور
    (function(){
  // Pause/resume labels animation helpers (if you kept your labels cycle)
  function pauseLabels(container) {
    container?.querySelectorAll && container.querySelectorAll('.labels').forEach(lb => {
      lb._paused = true;
    });
  }
  function resumeLabels(container) {
    container?.querySelectorAll && container.querySelectorAll('.labels').forEach(lb => {
      lb._paused = false;
    });
  }

  // Initialize all sliders
  document.querySelectorAll('.fancy-slider').forEach((slider, sliderIndex) => {
    const track = slider.querySelector('.slider-track');
    const slides = Array.from(slider.querySelectorAll('.slide'));
    const dots = Array.from(slider.querySelectorAll('.dot'));
    let index = 0;
    let isDragging = false;
    let startX = 0;
    let currentTranslate = 0;
    let prevTranslate = 0;
    let animationID = 0;
    const slideCount = slides.length;

    // mark first active
    if (slides[0]) slides[0].classList.add('active');
    if (dots[0]) dots[0].classList.add('active');

    // helpers
    const setPositionByIndex = (i, withTransition = true) => {
      index = (i + slideCount) % slideCount;
      const translateX = -index * slider.clientWidth;
      if (!withTransition) track.style.transition = 'none';
      else track.style.transition = '';
      track.style.transform = `translateX(${translateX}px)`;
      slides.forEach((s, si) => s.classList.toggle('active', si === index));
      dots.forEach((d, di) => d.classList.toggle('active', di === index));
      prevTranslate = translateX;
    };

    // Pointer events for drag (works mouse & touch & pen)
    const onPointerDown = (e) => {
      isDragging = true;
      startX = e.clientX ?? (e.touches ? e.touches[0].clientX : 0);
      track.style.transition = 'none';
      pauseLabels(slider); // pause label animation during drag
      slider.setPointerCapture?.(e.pointerId); // optional
    };
    const onPointerMove = (e) => {
      if (!isDragging) return;
      const currentX = e.clientX ?? (e.touches ? e.touches[0].clientX : 0);
      const delta = currentX - startX;
      const move = prevTranslate + delta;
      track.style.transform = `translateX(${move}px)`;
    };
    const onPointerUp = (e) => {
      if (!isDragging) return;
      isDragging = false;
      const endX = e.clientX ?? (e.changedTouches ? e.changedTouches[0].clientX : 0);
      const delta = endX - startX;
      const threshold = slider.clientWidth * 0.18; // كيفية تحديد التغيير للـ swipe
      if (delta < -threshold) {
        setPositionByIndex(index + 1);
      } else if (delta > threshold) {
        setPositionByIndex(index - 1);
      } else {
        setPositionByIndex(index); // snap back
      }
      resumeLabels(slider); // resume labels animation
    };

    // attach pointer listeners (pointer events preferred)
    slider.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);

    // touch fallback (some browsers)
    slider.addEventListener('touchstart', (e)=> onPointerDown(e), {passive:true});
    slider.addEventListener('touchmove', (e)=> onPointerMove(e), {passive:true});
    slider.addEventListener('touchend', (e)=> onPointerUp(e));

    // click on dots
    dots.forEach((dot, di) => {
      dot.addEventListener('click', (ev) => {
        setPositionByIndex(di);
      });
    });

    // resize: recalc translate to keep same index visible
    window.addEventListener('resize', () => {
      setPositionByIndex(index, false);
    });

    // initial sizing position
    setPositionByIndex(0, false);
  });

  // ---- labels cycle: upgraded to support pause flag (_paused)
  document.querySelectorAll(".labels").forEach(labelBox => {
    const spans = labelBox.querySelectorAll("span");
    let index = 0;
    let stopped = false;

    function cycleLabels() {
      if (labelBox._paused) {
        setTimeout(cycleLabels, 300);
        return;
      }
      spans.forEach(span => span.classList.remove("show", "hide"));
      spans[index].classList.add("show");

      setTimeout(() => {
        spans[index].classList.add("hide");
        index = (index + 1) % spans.length;
        setTimeout(cycleLabels, 800);
      }, 1200);
    }

    if (spans.length > 0) cycleLabels();
  });

})();
  </script>
</body>
</html>